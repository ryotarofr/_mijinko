## CRDT（Conflict-free Replicated Data Type）関連

基本的に後勝ちの処理になってる -> 時刻を管理していて後からの更新で上書き(この時差分がない場合は更新しない)

#### データ構造

最小コード

```rs
let mut oplog = use_signal(ListOpLog::new);
let agent = oplog.write().get_or_create_agent_id("ryotarofr");

oplog.write().add_insert(agent, 0, "Hello World!!!");

info!("{:?}", oplog);
```

oplogの中身

```json
 OpLog { doc_id: None, client_with_localtime: RleVec([KVPair(0, CRDTSpan { agent: 0, seq_range: T 0..14 })]), client_data: [ClientData { name: "ryotarofr", item_times: RleVec([KVPair(0, T 0..14)]) }], operation_ctx: OperationCtx { ins_content: [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 33, 33], del_content: [] }, operations: RleVec([KVPair(0, OperationInternal { loc: RangeRev { span: T 0..14, fwd: true }, kind: Ins, content_pos: Some(T 0..14) })]), history: History { entries: RleVec([HistoryEntry { span: T 0..14, shadow: 4294967295, parents: [], child_indexes: [] }]), root_child_indexes: [0] }, version: [13] }
 ```

```rs
cargo add diamond_types
```

普通にインストールしても最新版じゃない(v1.0.0だとOplogなどメインの構造体がprivateになってたりして遊べないので)

```toml
diamond-types = { git = "https://github.com/ryotarofr/diamond-types" }
```

とりあえずフォークして埋め込む

#### TODO

- [ ] CRDTと`editor.rs`の連携
  1. [ ] 行ごとに変更があればRedisに更新を投げる
  2. [ ] 行の確保 他ユーザがマージできない様にする
  3. [ ] 確保時間に制限をつける(一生解放されないと困る)

- [ ] `editor.rs`のパフォーマンス改善
  1. 行が切り替わるタイミングでレンダリング入れる(差分がなければ更新しない)
  -> 差分がなければCRDTの情報更新ロジックを発火させたくない

- [ ]マークダウンパサー

### Editor関連

divで作成。
改行ごとに`id`, `line`で制御 -> 例 `id=L1` `line=1`

#### TODO

- [ ] `shift + enter`で行の改行しない
- [ ]IME対応

### 少し意識したいこと

- マーケティングに強いコンテンツであるか
- 使い手がどう感じるものか(届け方をどの様に工夫するか)を考えながら

### メモ

リンク: <https://www.inkandswitch.com/peritext/?utm_source=geoffreylitt&utm_medium=email>

リアルタイムの共同作業はストレスの多い経験

### アイデア(本当に関係ない)

- 日本語英語フィルター(まあ好きな言語のフィルター的な感じでチラチラしながら言語学習ができるといいな)

### 2024/11/20

何やるか(まあその時思ったことをやればいいけど何も思わなかった時のために)

- [ ]マークダウンパサー <- とりあえずこれ

### 2024/11/23

とりあえず、できたもの

- 字句解析器

代用でなんとかなりそうなもの

- IME対応 -> 例えば 'cmd' + '何か' でモードの切り替えをする感じにする

### 2024/11/24

cmd + k 押した時に、わかりやすいメッセージを出したい

自分が書いた記事以外はread-onlyにしたい

マークダウン

- [-]見出し
- [ ]コードブロック
- [ ]No.リスト
- [ ]テーブル
- [ ]斜体
- [ ]太字
- [ ]下線

## 2024/12/1

追加実装

- Compomenntのパースの仕組み
問題点
 一回目のレンダリングで表示できない

## 2024/12/2

src/components/editor.rs
271~276行目実装 -> ":"押下時にカスタムコンポーネントレンダリング 1回目に表示できてはいない
また、カスタムコンポーネントは行始め出ないと実行できない

## 2024/12/3

テキストエディタ

- 行ごとに直近の入力インデックスを保持するモードを作りたい
- ディベロップモードでサーバーレンダリングとクライアントレンダリングを分離させる(データ部分のCSSを変更する形で良いかな？)

## 2024/12/2追記

- markdown上でdioxusのコンポーネント作れるようにしたい -> 結構無理そうやけど
-> 2024/12/9追記 専用のコードブロック(コードエディタ)を埋め込むことができれば可能
- csvやglob,fb2ファイルをレンダリングできるようにしたい(それを売買できるとなお良い)
-> Dioxus v0.6で実装追加

## 2024/12/4追記

- Autocompleteはユーザごとにローカルパスとかにunicodeなどをjsonで保存していく形式にするようにできるのか、それかredisでできるのか
-> 変数に書き込んでいってどっかのタイミングで一斉に更新処理走らせるほうが良いのか
-> ローカルストレージに書き込むことができればそれが一番丸い

## 2024/12/5

- クリックでの行移動ができるようにしたい
- コピペをフォーマットを崩さずに行えるようにしたい

## 2024/12/7

Autocompleteはsnwのpulldown使おう

## 2024/12/8

「シフト + 矢印キー」実装

## 2024/12/9

初期表示でデータ取得する場合に、「use_effect + useApiMutation」ではなくて外部関数(コンテキスト等)が読み込まれたときに初期取得で「useApiQuery」を使うのが良い

知識は検索性を考えて格納していく
-> それをサポート売る仕組みは必要

共有したければ共有して
-> メモとかのクオリティ向上

## 2024/12/13

BE-FEで大量のデータを送る際はJsonをStringにして送っている
-> 今回は大量のテキストのやり取りをするのでこの方法が良い？
-> Redisを使うにしても同じことがいえるのか？

wasmをうまく利用して、数式のアニメーション化できるのでは?!

githubの草みたいなやつは作りたい

### 可読性について(メモ)

useStateをどう使えばいいか
大量のstateを見て、可読性という観点でどのように管理するのがよいか疑問に思った

callbackについて
データをコールバックするのはどこまでを基準とすればよいか
-> 例えば関数何個までとか
  -> 個人的には2つ上の関数でまでコールバックする場合にはコンテキスト(class)にした方がいいと思っている

use_resourceを使えば、同ファイル上に置かれた、apiqueryを2回発火する問題を解消できる？

## 2024/12/18

### メモ帳の検索性について

ツェッテルカステンで必要要素の一つとして検索性の良さがある

どうやったら検索性が上がるのか？

- 単純な検索
  - 文字検索、タグ検索、日付検索
- 応用の検索
  - クラスター検索(タグ検索したキーワードと関連性の高いワードの検索) -> アルゴリズム調べる
  - スコア検索(必要なメモのみに閲覧数等の記録を付ける。何度も閲覧しているものにスコアを付与)
