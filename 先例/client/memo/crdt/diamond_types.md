# 俺が考えるCRDTにしたい

## diamond_typesについて

漸進的な操作を想定した設計になっている。
-> 「最初に巨大なデータを一括変換して終わり」という使い方は想定外。
-> 高価な構造変換はあまりやりたくない
(自分の体感的にはブラウザで1000byte以上のデータを一括で挿入することはそれなりに高価な操作であると思う)

ここでは（小〜中規模のデータ1000文字以下であれば）“そこそこ軽量”に展開できるを目指す。

### ListOpLogについて

リスト（または文字列）に対する「挿入」「削除」といった操作（Op）をログとして保持・合成し、最終的なリスト状態を得る仕組み。

### 自前で用意した型とどのように結合するのが良いか？

自前の実装は「行単位でテキストデータを格納する」構造となっている。
「行単位で格納する」がdiamond_typesと相性が悪く、初期表示の一括展開時に、それなりに高いオーバーヘッドが発生してしまう。

**編集内容の差分があった部分の情報のみを保存するようにするのが良いのでは？**
そのほかのメタ情報・テキスト情報は違う`Memo`の形式でそのままMongoDBに投げる。

差分情報のみをdiamond_typesで管理。
差分情報をMongoDB「_rev」で管理。マージの仕組みはアプリ側で実装。

### どうやるか

`mij commit -m "コメント"(コミットコマンド)`でコミットした場合に、ローカルの内容をDBに反映
-> コミット前のローカルの編集内容はローカスストレージに保存しておく

### diamond_types が想定しているユースケース

「挿入・削除」差分情報をネットワークで共有する用途で使われるのが典型例になる。

「最初にそこそこなサイズの文書を読み込んで開始し、その後はユーザーが文字をタイプする都度、小さな操作を蓄積しながら同期していく」ようなイメージ。

###
